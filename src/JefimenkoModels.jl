module JefimenkoModels
    using ForwardDiff
    using HCubature
    using LinearAlgebra
    using StaticArrays
    using Unitful
    using Unitful.DefaultSymbols: A, V, C, m, s, rad
    using UnitfulCoordinateSystems

    ###########################################################################
    #                        DATA STRUCTURES
    ###########################################################################

    abstract type JefimenkoSource{T} end

        abstract type VolumeSource{T} <: JefimenkoSource{T} end

            struct VolumeSource_Rectangular{T} <: VolumeSource{T}
                xlims::Tuple{Unitful.Length, Unitful.Length}
                ylims::Tuple{Unitful.Length, Unitful.Length}
                zlims::Tuple{Unitful.Length, Unitful.Length}
                œÅ‚Çë::Function
                œÅ‚Çï::Function
                J‚Çë::Function
                J‚Çï::Function
            end

            struct VolumeSource_Cylinder{T} <: VolumeSource{T}
                r::Tuple{Unitful.Length, Unitful.Length}
                œïlims::Tuple{Unitful.Length, Unitful.Length}
                zlims::Tuple{Unitful.Length, Unitful.Length}
                œÅ‚Çë::Function
                œÅ‚Çï::Function
                J‚Çë::Function
                J‚Çï::Function
            end

            struct VolumeSource_Sphere{T} <: VolumeSource{T}
                r::Tuple{Unitful.Length, Unitful.Length}
                Œ∏lims::Tuple{Unitful.Length, Unitful.Length}
                œïlims::Tuple{Unitful.Length, Unitful.Length}
                œÅ‚Çë::Function
                œÅ‚Çï::Function
                J‚Çë::Function
                J‚Çï::Function
            end

        abstract type SurfaceSource{T} <: JefimenkoSource{T} end

            struct SurfaceSource_Rectangle{T} <: SurfaceSource{T}
                xlims::Tuple{Unitful.Length, Unitful.Length}
                ylims::Tuple{Unitful.Length, Unitful.Length}
                œÅ‚Çë::Function
                œÅ‚Çï::Function
                J‚Çë::Function
                J‚Çï::Function
            end

            abstract type SurfaceSource_Disk{T} <: SurfaceSource{T} end

                struct SurfaceSource_Disk_General{T} <: SurfaceSource_Disk{T}
                    œÅ‚ÇÄ::Unitful.Length
                    œÅ‚Çë::Function
                    œÅ‚Çï::Function
                    J‚Çë::Function
                    J‚Çï::Function
                end

                struct SurfaceSource_Disk_CurrentsOnly{T} <: SurfaceSource_Disk{T}
                    œÅ‚ÇÄ::Unitful.Length
                    J‚Çë::Function
                    J‚Çï::Function
                end

                struct SurfaceSource_Disk_ElectricOnly{T} <: SurfaceSource_Disk{T}
                    œÅ‚ÇÄ::Unitful.Length
                    œÅ‚Çë::Function
                    J‚Çë::Function
                end

        abstract type LineSource{T} <: JefimenkoSource{T} end

            abstract type LineSource_Straight{T} <: LineSource{T} end

                struct LineSource_Straight_General{T} <: LineSource_Straight{T}
                    aÃÑ::CoordinateCartesian
                    bÃÑ::CoordinateCartesian
                    œÅ‚Çë::Function
                    œÅ‚Çï::Function
                    J‚Çë::Function
                    J‚Çï::Function
                end

                struct LineSource_Straight_ElectricOnly{T} <: LineSource_Straight{T}
                    aÃÑ::CoordinateCartesian
                    bÃÑ::CoordinateCartesian
                    œÅ‚Çë::Function
                    J‚Çë::Function
                end

                struct LineSource_Straight_CurrentsOnly{T} <: LineSource_Straight{T}
                    aÃÑ::CoordinateCartesian
                    bÃÑ::CoordinateCartesian
                    J‚Çë::Function
                    J‚Çï::Function
                end

    export VolumeSource_Rectangular, VolumeSource_Cylinder, VolumeSource_Sphere
    export SurfaceSource_Rectangle
    export SurfaceSource_Disk_General,  SurfaceSource_Disk_CurrentsOnly,  SurfaceSource_Disk_ElectricOnly
    export LineSource_Straight_General, LineSource_Straight_CurrentsOnly, LineSource_Straight_ElectricOnly

    abstract type PropagationMedia end

        struct PropagationMedia_Simple <: PropagationMedia
            Œµ::Quantity
            Œº::Quantity
            c::Quantity
        end

        struct PropagationMedia_DiagonallyAnisotropic <: PropagationMedia
            Œµ::Diagonal{Quantity}
            Œº::Diagonal{Quantity}
            c::Diagonal{Quantity}
        end
    
        export PropagationMedia_Simple, PropagationMedia_DiagonallyAnisotropic

    struct JefimenkoModel{T}
        media::PropagationMedia
        sources::Vector{JefimenkoSource{T}}
        metadata::Dict{Symbol,Any}
    end

    export PropagationMedia, JefimenkoModel

    ###########################################################################
    #                            INTERNAL FUNCTIONS
    ###########################################################################

    t·µ£(rÃÑ::Coordinate, t::Unitful.Time, rÃÑ‚Ä≤::Coordinate, c::Quantity)::Unitful.Time = t - (norm(rÃÑ-rÃÑ‚Ä≤)/c)

    function ùêàe(rÃÑ‚Ä≤::Coordinate; rÃÑ::Coordinate, t::Unitful.Time, media::PropagationMedia_Simple, source::SurfaceSource_Disk_General{T}) where {T<:AbstractFloat}
        rÃÑ‚Ä≤_cart = CoordinateCartesian(rÃÑ‚Ä≤)
        ŒîrÃÑ_m = ustrip.(T, m, SVector(rÃÑ - rÃÑ‚Ä≤_cart))
        r_m = norm(ŒîrÃÑ_m)
        œÅ_m = ustrip(T, m, UnitfulCoordinateSystems.œÅ(rÃÑ‚Ä≤))
        c = ustrip(T, m/s, media.c)
        Œµ = ustrip(T, A*s/(V*m), media.Œµ)

        tr_s::T = ustrip(T, s, t·µ£(rÃÑ,t,rÃÑ‚Ä≤,media.c))        # retarded time in s

        # Source functions
        œÅ‚Çë(t::Real) = source.œÅ‚Çë(rÃÑ‚Ä≤_cart, t)               # in C m^-2
        ‚àÇœÅ‚Çë_‚àÇt(t::Real) = ForwardDiff.derivative(œÅ‚Çë, t)   # in C m^-2 s^-1
        J‚Çë(t::Real) = source.J‚Çë(rÃÑ‚Ä≤_cart, t)               # in A m^-1
        ‚àÇJ‚Çë_‚àÇt(t::Real) = ForwardDiff.derivative(J‚Çë, t)   # in A m^-1 s^-1
        J‚Çï(t::Real) = source.J‚Çï(rÃÑ‚Ä≤_cart, t)                # in V m^-1
        ‚àÇJ‚Çï_‚àÇt(t::Real) = ForwardDiff.derivative(J‚Çï, t)    # in V m^-1 s^-1

        # Calculate first term
        term1a = ( (ŒîrÃÑ_m ./ r_m^3) .* œÅ‚Çë(tr_s) )                # [m/m^3 * C/m^2]         -> [A*s/m^4]
        term1b = ( (ŒîrÃÑ_m ./ r_m^2) .* (c^-1) .* ‚àÇœÅ‚Çë_‚àÇt(tr_s) )  # [m/m^2 * s/m * C/sm^-2] -> [A*s/m^4]
        term1c = ( (1 / r_m) .* (c^-2) .* ‚àÇJ‚Çë_‚àÇt(tr_s) )        # [1/m * s^2/m^2 * A/sm]  -> [A*s/m^4]
        term1  = ( (Œµ^-1) .* (term1a + term1b - term1c) )       # [Vm/As * As/m^4] -> [V/m^3]
        
        # Calculate second term
        term2a = ( J‚Çï(tr_s) ./ r_m^3 )                          # [V/m / m^3] -> [V/m^4]
        term2b = ( (1 / r_m^2) .* (c^-1) .* ‚àÇJ‚Çï_‚àÇt(tr_s) )      # [1/m^2 * s/m * V/sm] -> [V/m^4]
        term2  = cross((term2a + term2b), ŒîrÃÑ_m)                 # [V/m^4 * m] -> [V/m^3]

        # Combine terms and apply integration factor
        return ( (term1 - term2) * œÅ_m )  # [V/m^3 * m] -> [V/m^2]
    end

    function ùêàe(rÃÑ‚Ä≤::Coordinate; rÃÑ::Coordinate, t::Unitful.Time, media::PropagationMedia_Simple, source::SurfaceSource_Disk_ElectricOnly{T}) where {T<:AbstractFloat}
        rÃÑ‚Ä≤_cart = CoordinateCartesian(rÃÑ‚Ä≤)
        ŒîrÃÑ_m = ustrip.(T, m, SVector(rÃÑ - rÃÑ‚Ä≤_cart))
        r_m = norm(ŒîrÃÑ_m)
        œÅ_m = ustrip(T, m, UnitfulCoordinateSystems.œÅ(rÃÑ‚Ä≤))
        c = ustrip(T, m/s, media.c)
        Œµ = ustrip(T, A*s/(V*m), media.Œµ)

        tr_s::T = ustrip(T, s, t·µ£(rÃÑ,t,rÃÑ‚Ä≤,media.c))        # retarded time in s

        # Source functions
        œÅ‚Çë(t::Real) = source.œÅ‚Çë(rÃÑ‚Ä≤_cart, t)               # in C m^-2
        ‚àÇœÅ‚Çë_‚àÇt(t::Real) = ForwardDiff.derivative(œÅ‚Çë, t)   # in C m^-2 s^-1
        J‚Çë(t::Real) = source.J‚Çë(rÃÑ‚Ä≤_cart, t)               # in A m^-1
        ‚àÇJ‚Çë_‚àÇt(t::Real) = ForwardDiff.derivative(J‚Çë, t)   # in A m^-1 s^-1

        # Calculate first term
        term1a = ( (ŒîrÃÑ_m ./ r_m^3) .* œÅ‚Çë(tr_s) )                # [m/m^3 * C/m^2]         -> [A*s/m^4]
        term1b = ( (ŒîrÃÑ_m ./ r_m^2) .* (c^-1) .* ‚àÇœÅ‚Çë_‚àÇt(tr_s) )  # [m/m^2 * s/m * C/sm^-2] -> [A*s/m^4]
        term1c = ( (1 / r_m) .* (c^-2) .* ‚àÇJ‚Çë_‚àÇt(tr_s) )        # [1/m * s^2/m^2 * A/sm]  -> [A*s/m^4]
        term1  = ( (Œµ^-1) .* (term1a + term1b - term1c) )       # [Vm/As * As/m^4] -> [V/m^3]

        # Apply integration factor
        return ( term1 * œÅ_m )  # [V/m^3 * m] -> [V/m^2]
    end

    function ùêàe(rÃÑ‚Ä≤::Coordinate; rÃÑ::Coordinate, t::Unitful.Time, media::PropagationMedia_Simple, source::SurfaceSource_Disk_CurrentsOnly{T}) where {T<:AbstractFloat}
        rÃÑ‚Ä≤_cart = CoordinateCartesian(rÃÑ‚Ä≤)
        ŒîrÃÑ_m = ustrip.(T, m, SVector(rÃÑ - rÃÑ‚Ä≤_cart))
        r_m = norm(ŒîrÃÑ_m)
        œÅ_m = ustrip(T, m, UnitfulCoordinateSystems.œÅ(rÃÑ‚Ä≤))
        c = ustrip(T, m/s, media.c)
        Œµ = ustrip(T, A*s/(V*m), media.Œµ)

        tr_s::T = ustrip(T, s, t·µ£(rÃÑ,t,rÃÑ‚Ä≤,media.c))        # retarded time in s

        # Source functions
        J‚Çë(t::Real) = source.J‚Çë(rÃÑ‚Ä≤_cart, t)               # in A m^-1
        ‚àÇJ‚Çë_‚àÇt(t::Real) = ForwardDiff.derivative(J‚Çë, t)   # in A m^-1 s^-1
        J‚Çï(t::Real) = source.J‚Çï(rÃÑ‚Ä≤_cart, t)                # in V m^-1
        ‚àÇJ‚Çï_‚àÇt(t::Real) = ForwardDiff.derivative(J‚Çï, t)    # in V m^-1 s^-1

        # Calculate first term
        term1c = ( (1 / r_m) .* (c^-2) .* ‚àÇJ‚Çë_‚àÇt(tr_s) )    # [1/m * s^2/m^2 * A/sm]  -> [A*s/m^4]
        term1  = ( (Œµ^-1) .* (-term1c) )                    # [Vm/As * As/m^4] -> [V/m^3]
        
        # Calculate second term
        term2a = ( J‚Çï(tr_s) ./ r_m^3 )                          # [V/m / m^3] -> [V/m^4]
        term2b = ( (1 / r_m^2) .* (c^-1) .* ‚àÇJ‚Çï_‚àÇt(tr_s) )      # [1/m^2 * s/m * V/sm] -> [V/m^4]
        term2  = cross((term2a + term2b), ŒîrÃÑ_m)                 # [V/m^4 * m] -> [V/m^3]

        # Combine terms and apply integration factor
        return ( (term1 - term2) * œÅ_m )  # [V/m^3 * m] -> [V/m^2]
    end

    ###########################################################################
    #                       ùêÑ-FIELD FUNCTIONS
    ###########################################################################

    function ùêÑ(rÃÑ::Coordinate, t::Unitful.Time, model::JefimenkoModel; rtol=sqrt(eps()))
        # Sum the contributions of the ùêÑ(rÃÑ,t) produced by each source in model
        E_contrib(source) = ùêÑ(rÃÑ, t, source; media=model.media, rtol=rtol)
        return mapreduce(E_contrib, +, model.sources) 
    end

    function ùêÑ(rÃÑ::Coordinate, t::Unitful.Time, source::SurfaceSource_Disk{T}; media::PropagationMedia, rtol=sqrt(eps())) where {T<:AbstractFloat}
        # Define an shim function since HCubature doesn't currently support Unitful integration
        function integrand(coord)
            # coord -> [œÅ in m, œï in rad]
            rÃÑ‚Ä≤ = CoordinatePolar(coord[1]*m, coord[2]*rad)
            return ùêàe(rÃÑ‚Ä≤; rÃÑ=rÃÑ, t=t, media=media, source=source)
        end

        # Integrate over circular aperture.   [V/m^2 * m * []] -> [V/m]
        œÅ‚ÇÄ_m = ustrip(T, m, source.œÅ‚ÇÄ)
        iint = hcubature(integrand, [zero(T), zero(T)], [œÅ‚ÇÄ_m, T(2œÄ)], rtol=rtol)
        return ( (1/4œÄ) .* iint[1] .* (V/m) )
    end

    export ùêÑ

    ###########################################################################
    #                       ùêá-FIELD FUNCTIONS
    ###########################################################################

    function ùêá(model::JefimenkoModel, rÃÑ::Coordinate, t::Unitful.Time; rtol=sqrt(eps()))
        # Sum the contributions of the ùêá(rÃÑ,t) produced by each source in model
        return mapreduce(source -> ùêá(source, model.media, rÃÑ, t; rtol=rtol), +, model.sources) 
    end

    function ùêá(source::SurfaceSource_Disk, media::PropagationMedia, rÃÑ::Coordinate, t::Unitful.Time; rtol=sqrt(eps()))
        error("Not implemented yet.")
    end

    export ùêá
end
